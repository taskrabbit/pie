[% var project = h.t('project'); %]
[% var ns = h.t('ns'); %]
[% var possess = pie.string.change(project, 'capitalize', 'possessive'); %]

<div class="copy">
  <h1>Models</h1>
  <p>
    [%= project %] models provide a simple interface for object management and observation. They even provide computed properties, just like Ember models.
  </p>

  <h3>Model Basics</h3>
  <p>
    Until ES2015's Object.observe standard is in place, model activity is managed through getters and setters. Each model contains a <em>data</em> object which the getters and setters manipulate. You can bootstrap a model with data by providing it to the constructor
  </p>

  [%= h.gist("modelAccessors.js") %]

  <p>
    [%= project %] models allow for path management as well.
  </p>

  [%= h.gist("modelPaths.js") %]

  <h3>Computed Properties</h3>
  <p>
    Models are given the ability to define properties which are computed based on other properties of the model. This is accomplished via the <em>compute</em> method.
  </p>

  [%= h.gist("modelComputed.js") %]

  <p>
    The <em>compute</em> method accepts the property name, functional definition, and the dependent properties (or paths). If the functional definition is ommitted, a function of the provided name will be retrieved from the instance itself. This is useful when dealing with inheritance.
  </p>

  [%= h.gist("modelComputed2.js") %]

  <h3>Observation</h3>
  <p>
    Attributes, paths, and subpaths of a model can be observed. Observers are invoked after a <em>set</em>, <em>sets</em>, or <em>merge</em> operation is conducted. When invoked, observers receive an array of change records. The array is enhanced with extra functionality as defined by the <em>changeSet</em> mixin.
  </p>

  [%= h.gist("modelObserver.js") %]

  <h5>ChangeSets</h5>

  <p>
    When an observer is triggered it's always provided with a changeSet object. This object is an array, with some extra functionality. Here's what you can do with a changeSet.
  </p>

  <ul>
    <li>
      <code>*</code>
      <span>- every Array.prototype function.</span>
    </li>
    <li>
      <code>get(key)</code>
      <span>- access the most recent change record associated with the given key.</span>
    </li>
    <li>
      <code>has(key)</code>
      <span>- does the changeSet contain a record with the given key.</span>
    </li>
    <li>
      <code>hasAny(*keys)</code>
      <span>- are there any change records that match any of the given keys?</span>
    </li>
    <li>
      <code>hasAll(*keys)</code>
      <span>- are all of the provided keys present in the given change records?</span>
    </li>
    <li>
      <code>query(options)</code>
      <span>- query for the latest change set by name and/or type.</span>
      <br />
      <ul>
        <li><code>changeSet.query({name: "firstName", type: "update"})</code></li>
      </ul>
    </li>
    <li>
      <code>queryAll(options)</code>
      <span>- query for all change records matching the name and/or type.</span>
      <br />
      <ul>
        <li><code>changeSet.queryAll({type: "update"})</code></li>
      </ul>
    </li>
  </ul>

</div>
